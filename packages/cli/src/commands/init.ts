import { Args, Flags } from '@oclif/core';
import { BaseCommand } from '../lib/base-command.js';
import prompts from 'prompts';
import { existsSync } from 'fs';
import { writeFile } from 'fs/promises';
import path from 'path';
import yaml from 'yaml'; // Using the yaml library from @devx/stack

/**
 * Defines the structure for the basic `.stack.yml` configuration generated by the `init` command.
 */
interface GeneratedStackConfig {
  /** Unique name for the stack. */
  name: string;
  /** Version of the configuration format or stack. */
  version: string;
  /** Map of service definitions. Key is service name. */
  services: {
    [key: string]: {
      /** Container image to use for the service. */
      image: string;
      /** Optional port mappings (host:container). */
      ports?: string[];
    };
  };
  // TODO: Add builder/engine properties if they should be configurable during init
}

/**
 * Oclif command for initializing a new DevX stack configuration (`.stack.yml`).
 * Supports both interactive (TUI) and non-interactive (key=value arguments) modes.
 */
export default class Init extends BaseCommand<typeof Init> {
  static description =
    'Initializes a new DevX stack configuration (`.stack.yml`).';

  static examples = [
    '$ devx init', // Interactive TUI
    '$ devx init --name my-project', // Specify name via flag
    // Example parsing key=value pairs (requires strict: false)
    '$ devx init web=nginx:latest db=postgres:15 ports.web=8080:80',
  ];

  static strict = false;

  static flags = {
    force: Flags.boolean({
      char: 'f',
      description: 'Overwrite existing .stack.yml file.',
      default: false,
    }),
    name: Flags.string({
      description: 'Name of the stack (defaults to directory name)',
    }),
    // TODO: Add flags for common options like --builder, --engine if needed
    ...BaseCommand.baseFlags,
  };

  static args = {};

  /**
   * Parses key=value pairs from the raw command-line arguments (`this.argv`).
   * Filters out flags and only considers arguments containing '='.
   * Handles a special case for `ports.servicename=host:container`.
   *
   * @param argv Raw command-line arguments array.
   * @returns A record mapping keys to values.
   */
  private parseKeyValueArgs(argv: string[]): Record<string, string> {
    const keyValueArgs: Record<string, string> = {};
    for (const arg of argv) {
      const parts = arg.split('=');
      if (parts.length === 2 && parts[0] && parts[1]) {
        // Basic parsing, could be enhanced (e.g., handle quotes)
        // Special handling for ports.servicename=host:container
        keyValueArgs[parts[0].trim()] = parts[1].trim();
      }
      // Ignore args that don't match key=value
    }
    return keyValueArgs;
  }

  /**
   * Main execution method for the `init` command.
   * Checks for existing configuration, determines initialization mode (interactive vs. args),
   * generates the configuration object, converts it to YAML, and writes the `.stack.yml` file.
   *
   * @throws {Error} If file writing fails or if `.stack.yml` exists without `--force`.
   */
  async run(): Promise<void> {
    const forceFlag = this.flags.force;
    const nameFlag = this.flags.name;

    // Simpler filtering for key=value pairs:
    // Assume anything containing '=' and not starting with '-' is a key=value pair.
    const rawKeyValues = this.argv.filter(
      (arg) => arg.includes('=') && !arg.startsWith('-')
    );
    const keyValueArgs = this.parseKeyValueArgs(rawKeyValues);

    const targetPath = path.resolve('.stack.yml');

    if (existsSync(targetPath) && !forceFlag) {
      this.error(
        `Configuration file already exists at ${targetPath}. Use --force to overwrite.`
      );
      return; // error exits
    }

    let stackConfig: GeneratedStackConfig;

    if (Object.keys(keyValueArgs).length > 0) {
      this.log('Initializing from command line arguments...');
      stackConfig = this.createConfigFromArgs(nameFlag, keyValueArgs);
    } else {
      this.log('Initializing interactively...');
      stackConfig = await this.runInteractiveInit(nameFlag);
    }

    const yamlContent = yaml.stringify(stackConfig);

    try {
      await writeFile(targetPath, yamlContent);
      this.log(`Successfully created stack configuration at ${targetPath}`);
      // Optionally log content
    } catch (error) {
      this.error(`Failed to write configuration file: ${error}`);
    }
  }

  /**
   * Creates a basic stack configuration object based on key=value command-line arguments.
   *
   * @param stackNameFlag The stack name provided via the `--name` flag, if any.
   * @param args Parsed key=value arguments from the command line.
   * @returns The generated stack configuration object.
   */
  private createConfigFromArgs(
    stackNameFlag: string | undefined,
    args: Record<string, string>
  ): GeneratedStackConfig {
    const stackName = stackNameFlag ?? path.basename(process.cwd());
    const config: GeneratedStackConfig = {
      name: stackName,
      version: '1.0.0',
      services: {},
    };

    for (const [key, value] of Object.entries(args)) {
      if (key.startsWith('ports.')) {
        // Handle ports.servicename=host:container
        const serviceName = key.substring(6); // Remove 'ports.'
        if (config.services[serviceName]) {
          if (!config.services[serviceName].ports) {
            config.services[serviceName].ports = [];
          }
          config.services[serviceName].ports!.push(value);
        } else {
          this.warn(
            `Port specified for unknown service '${serviceName}'. Define the service first (e.g., ${serviceName}=image:tag).`
          );
        }
      } else {
        // Assume other key=value pairs define services: name=image:tag
        if (!config.services[key]) {
          config.services[key] = { image: value };
        } else {
          // If service exists (maybe from a port arg first?), just set image
          config.services[key].image = value;
        }
      }
    }

    if (Object.keys(config.services).length === 0) {
      this.warn(
        'No services defined via arguments. Creating an empty services block.'
      );
    }

    return config;
  }

  /**
   * Runs an interactive terminal UI using the `prompts` library to gather
   * stack configuration details from the user.
   *
   * @param stackNameFlag The stack name provided via the `--name` flag, used as a default.
   * @returns A promise that resolves to the generated stack configuration object based on user input.
   */
  private async runInteractiveInit(
    stackNameFlag: string | undefined
  ): Promise<GeneratedStackConfig> {
    const stackNameDefault = stackNameFlag ?? path.basename(process.cwd());

    const responses = await prompts([
      {
        type: 'text',
        name: 'name',
        message: 'Stack name',
        initial: stackNameDefault,
      },
      {
        type: 'text',
        name: 'version',
        message: 'Stack version',
        initial: '1.0.0',
      },
      {
        type: 'list',
        name: 'services',
        message: 'Add services (comma-separated, e.g., web=nginx,db=postgres)',
        initial: '',
        separator: ',',
      },
      // Add more prompts for services, ports, volumes etc. as needed
      // This is a very basic example
    ]);

    // Process responses to build the config structure
    const config: GeneratedStackConfig = {
      name: responses.name,
      version: responses.version,
      services: {},
    };

    if (responses.services && Array.isArray(responses.services)) {
      for (const serviceStr of responses.services) {
        const parts = serviceStr.trim().split('=');
        if (parts.length === 2 && parts[0] && parts[1]) {
          const serviceName = parts[0].trim();
          const imageName = parts[1].trim();
          config.services[serviceName] = { image: imageName };
          // TODO: Add prompts for ports, volumes for each service?
        }
      }
    }

    return config;
  }
}
