import { Args, Flags } from '@oclif/core';
import { BaseCommand } from '../base-command';
import prompts, { PromptObject } from 'prompts';
import { existsSync } from 'fs';
import { writeFile } from 'fs/promises';
import path from 'path';
import yaml from 'yaml';
import { Recipe, RecipeOption } from '@devx/recipes';
import { StackConfig } from '@devx/stack';
import { getRecipe } from '@devx/recipes';

/**
 * Defines the structure for the basic `.stack.yml` configuration generated by the `init` command.
 */
type GeneratedStackConfig = StackConfig;

/**
 * Oclif command for initializing a new DevX stack configuration (`.stack.yml`).
 * Supports both interactive (TUI) and non-interactive (key=value arguments) modes.
 */
export default class Init extends BaseCommand {
  static description =
    'Initializes a new DevX stack configuration (`.stack.yml`).';

  static examples = [
    '$ devx init', // Interactive TUI
    '$ devx init --name my-project', // Specify name via flag
    '$ devx init --recipe lamp', // Use LAMP recipe
    '$ devx init --recipe lamp db=postgres web=nginx', // Use LAMP recipe with options
    // Example parsing key=value pairs (requires strict: false)
    '$ devx init web=nginx:latest db=postgres:15 ports.web=8080:80',
  ];

  static strict = false;

  static flags = {
    force: Flags.boolean({
      char: 'f',
      description: 'Overwrite existing .stack.yml file.',
      default: false,
    }),
    name: Flags.string({
      description: 'Name of the stack (defaults to directory name)',
    }),
    recipe: Flags.string({
      description: 'Use a predefined recipe (e.g., lamp)',
    }),
    ...BaseCommand.baseFlags,
  };

  static args = {};

  /**
   * Parses key=value pairs from the raw command-line arguments (`this.argv`).
   * Filters out flags and only considers arguments containing '='.
   * Handles a special case for `ports.servicename=host:container`.
   *
   * @param argv Raw command-line arguments array.
   * @returns A record mapping keys to values.
   */
  private parseKeyValueArgs(argv: string[]): Record<string, string> {
    const keyValueArgs: Record<string, string> = {};
    for (const arg of argv) {
      const parts = arg.split('=');
      if (parts.length === 2 && parts[0] && parts[1]) {
        // Basic parsing, could be enhanced (e.g., handle quotes)
        // Special handling for ports.servicename=host:container
        keyValueArgs[parts[0].trim()] = parts[1].trim();
      }
      // Ignore args that don't match key=value
    }
    return keyValueArgs;
  }

  /**
   * Main execution method for the `init` command.
   * Checks for existing configuration, determines initialization mode (interactive vs. args),
   * generates the configuration object, converts it to YAML, and writes the `.stack.yml` file.
   *
   * @throws {Error} If file writing fails or if `.stack.yml` exists without `--force`.
   */
  async run(): Promise<void> {
    const forceFlag = this.flags.force;
    const nameFlag = this.flags.name;
    const recipeFlag = this.flags.recipe;

    // Simpler filtering for key=value pairs:
    // Assume anything containing '=' and not starting with '-' is a key=value pair.
    const rawKeyValues = this.argv.filter(
      (arg) => arg.includes('=') && !arg.startsWith('-')
    );
    const keyValueArgs = this.parseKeyValueArgs(rawKeyValues);

    const targetPath = path.resolve('.stack.yml');

    if (existsSync(targetPath) && !forceFlag) {
      this.error(
        `Configuration file already exists at ${targetPath}. Use --force to overwrite.`
      );
      return; // error exits
    }

    let stackConfig: GeneratedStackConfig;

    if (recipeFlag) {
      try {
        const recipe = getRecipe(recipeFlag);
        this.log(`Using recipe: ${recipe.name} - ${recipe.description}`);
        
        if (Object.keys(keyValueArgs).length > 0) {
          this.log('Initializing from recipe with command line arguments...');
          // Apply command line arguments to the recipe's stack configuration
          stackConfig = this.applyRecipeOptions(recipe, keyValueArgs);
        } else {
          this.log('Initializing recipe interactively...');
          const recipeOptions = await this.runRecipeInteractiveInit(recipe);
          stackConfig = this.applyRecipeOptions(recipe, recipeOptions);
        }
      } catch (error) {
        if (error instanceof Error) {
          this.error(`Failed to initialize recipe: ${error.message}`);
        } else {
          this.error('An unknown error occurred while initializing the recipe');
        }
        return;
      }
    } else if (Object.keys(keyValueArgs).length > 0) {
      this.log('Initializing from command line arguments...');
      stackConfig = this.createConfigFromArgs(nameFlag, keyValueArgs);
    } else {
      this.log('Initializing interactively...');
      stackConfig = await this.runInteractiveInit(nameFlag);
    }

    const yamlContent = yaml.stringify(stackConfig);

    try {
      await writeFile(targetPath, yamlContent);
      this.log(`Successfully created stack configuration at ${targetPath}`);
      // Optionally log content
    } catch (error) {
      if (error instanceof Error) {
        this.error(`Failed to write configuration file: ${error.message}`);
      } else {
        this.error('An unknown error occurred while writing the configuration file');
      }
    }
  }

  /**
   * Runs an interactive terminal UI for recipe-specific options.
   * 
   * @param recipe The recipe to initialize
   * @returns A promise that resolves to the recipe options
   */
  private async runRecipeInteractiveInit(recipe: Recipe): Promise<Record<string, string>> {
    const questions: PromptObject[] = Object.entries(recipe.options || {}).map(([key, option]) => ({
      type: option.choices ? 'select' : 'text',
      name: key,
      message: option.description,
      initial: option.default,
      choices: option.choices?.map(choice => ({ title: choice, value: choice })),
    }));

    const responses = await prompts(questions);
    return responses;
  }

  /**
   * Applies recipe options to the base stack configuration
   * 
   * @param recipe The recipe to use
   * @param options The options to apply
   * @returns The modified stack configuration
   */
  private applyRecipeOptions(recipe: Recipe, options: Record<string, string>): GeneratedStackConfig {
    // Start with the base stack configuration from the recipe
    const stackConfig = { ...recipe.stack };

    // Apply any provided options that match the recipe's options
    if (recipe.options) {
      for (const [key, value] of Object.entries(options)) {
        if (recipe.options[key]) {
          // Here we could add validation against the recipe's option schema
          // For now, we just apply the option directly
          // In a real implementation, we would need to handle how each option
          // affects the stack configuration
          this.log(`Applying option ${key}=${value}`);
        }
      }
    }

    return stackConfig;
  }

  /**
   * Creates a basic stack configuration object based on key=value command-line arguments.
   *
   * @param stackNameFlag The stack name provided via the `--name` flag, if any.
   * @param args Parsed key=value arguments from the command line.
   * @returns The generated stack configuration object.
   */
  private createConfigFromArgs(
    stackNameFlag: string | undefined,
    args: Record<string, string>
  ): GeneratedStackConfig {
    const stackName = stackNameFlag ?? path.basename(process.cwd());
    const config: GeneratedStackConfig = {
      name: stackName,
      version: '1.0.0',
      services: {},
    };

    for (const [key, value] of Object.entries(args)) {
      if (key.startsWith('ports.')) {
        // Handle ports.servicename=host:container
        const serviceName = key.substring(6); // Remove 'ports.'
        if (config.services[serviceName]) {
          if (!config.services[serviceName].ports) {
            config.services[serviceName].ports = [];
          }
          config.services[serviceName].ports.push(value);
        } else {
          config.services[serviceName] = {
            ports: [value],
          };
        }
      } else if (key.includes('.')) {
        // Handle other service-specific settings (e.g., image.web=nginx)
        const [service, setting] = key.split('.');
        if (!config.services[service]) {
          config.services[service] = {};
        }
        config.services[service][setting] = value;
      } else {
        // Handle top-level settings
        (config as any)[key] = value;
      }
    }

    return config;
  }

  /**
   * Runs an interactive terminal UI for basic stack configuration.
   *
   * @param stackNameFlag The stack name provided via the `--name` flag, if any.
   * @returns A promise that resolves to the generated stack configuration.
   */
  private async runInteractiveInit(
    stackNameFlag: string | undefined
  ): Promise<GeneratedStackConfig> {
    const responses = await prompts([
      {
        type: 'text',
        name: 'name',
        message: 'Stack name',
        initial: stackNameFlag ?? path.basename(process.cwd()),
      },
      {
        type: 'text',
        name: 'version',
        message: 'Stack version',
        initial: '1.0.0',
      },
    ]);

    return {
      name: responses.name,
      version: responses.version,
      services: {},
    };
  }
}
